<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home ¬∑ PhotometricFilters.jl</title><meta name="title" content="Home ¬∑ PhotometricFilters.jl"/><meta property="og:title" content="Home ¬∑ PhotometricFilters.jl"/><meta property="twitter:title" content="Home ¬∑ PhotometricFilters.jl"/><meta name="description" content="Documentation for PhotometricFilters.jl."/><meta property="og:description" content="Documentation for PhotometricFilters.jl."/><meta property="twitter:description" content="Documentation for PhotometricFilters.jl."/><meta property="og:url" content="https://juliaastro.org/PhotometricFilters/stable/"/><meta property="twitter:url" content="https://juliaastro.org/PhotometricFilters/stable/"/><link rel="canonical" href="https://juliaastro.org/PhotometricFilters/stable/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>PhotometricFilters.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Accessing-Filter-Curves"><span>Accessing Filter Curves</span></a></li><li><a class="tocitem" href="#Applying-Filter-Curves-to-Spectra"><span>Applying Filter Curves to Spectra</span></a></li><li><a class="tocitem" href="#Zero-Points"><span>Zero Points</span></a></li><li><a class="tocitem" href="#Synthetic-Photometry"><span>Synthetic Photometry</span></a></li><li><a class="tocitem" href="#Statistics"><span>Statistics</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaAstro/PhotometricFilters.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PhotometricFilters"><a class="docs-heading-anchor" href="#PhotometricFilters">PhotometricFilters</a><a id="PhotometricFilters-1"></a><a class="docs-heading-anchor-permalink" href="#PhotometricFilters" title="Permalink"></a></h1><p>This package provides access to, and operations on, photometric filter curves. Such filter curves are defined by a filter&#39;s transmission as a function of wavelength. Transmission and wavelength vectors are therefore the foundation of a filter curve, but it is also important to note whether the filter is used for photon counter or energy counter detectors, as the integrals used to calculate statistics over a filter curve are different between these two types of detectors.</p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p>All photometric filter types should be subtypes of the <a href="#PhotometricFilters.AbstractFilter"><code>AbstractFilter</code></a> type. We define a minimal API that should be followed so that new types can make use of the generic filter operations we define.</p><p>The simplest concrete filter type we provide to represent photometric filters is <a href="#PhotometricFilters.PhotometricFilter"><code>PhotometricFilter</code></a>.</p><article><details class="docstring" open="true"><summary id="PhotometricFilters.PhotometricFilter"><a class="docstring-binding" href="#PhotometricFilters.PhotometricFilter"><code>PhotometricFilters.PhotometricFilter</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PhotometricFilter(wavelength::AbstractVector, throughput::AbstractVector{T};
                  detector::DetectorType=Photon(), filtername::Union{String, Nothing}=nothing) where T</code></pre><p>Struct representing a photometric filter, defined by vectors of wavelengths (<code>wavelength</code>) and filter throughputs (<code>throughput</code>). <code>wavelength</code> can have <code>Unitful</code> units attached, otherwise they are assumed to be √Ö. Optional keyword arguments define the detector type for which the filter is valid and a name to identify the filter.</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: PhotometricFilter, Photon, wavelength, throughput

julia&gt; using Unitful

julia&gt; f = PhotometricFilter(1000:2000, vcat(fill(0.25, 250), fill(0.5, 500), fill(0.25, 251))) # Specify only wavelength and throughput
1001-element PhotometricFilter{Float64}: nothing
 reference wave.: 1478.1028279485677 √Ö
 min. wave.: 1000 √Ö
 max. wave.: 2000 √Ö
 effective wave.: 1602.7669435459648 √Ö
 mean wave.: 1499.8333333333333 √Ö
 central wave.: 1499.5 √Ö
 pivot wave.: 1478.1028279485677 √Ö
 eff. width: 750.0 √Ö
 fwhm: 501.0 √Ö

julia&gt; f == PhotometricFilter(uconvert.(Unitful.nm, wavelength(f)), throughput(f)) # Can also specify wavelength argument with Unitful units
true

julia&gt; f[10] # Indexing into the filter as `f[i]` returns `(wavelength(f)[i], throughput(f)[i])`
(1009 √Ö, 0.25)

julia&gt; f(1001.1) # Calling `f` like a function interpolates the throughput
0.25

julia&gt; f(100.11 * Unitful.nm) # Can also specify wavelength with units
0.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L622-L657">source</a></section></details></article><p>The data contained in the struct can be accessed with the following methods:</p><article><details class="docstring" open="true"><summary id="PhotometricFilters.filtername"><a class="docstring-binding" href="#PhotometricFilters.filtername"><code>PhotometricFilters.filtername</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">filtername(f::AbstractFilter)</code></pre><p>Returns a string indicating a human-readable name for the filter (e.g., &quot;SDSS_u&quot;).</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: SDSS_u, filtername

julia&gt; filtername(SDSS_u())
&quot;SDSS_u&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L170-L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.wavelength"><a class="docstring-binding" href="#PhotometricFilters.wavelength"><code>PhotometricFilters.wavelength</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">wavelength(f::AbstractFilter)</code></pre><p>Returns the wavelength vector of the filter transmission curve with proper <code>Unitful.jl</code> units.</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: SDSS_u, wavelength

julia&gt; using Unitful: Quantity

julia&gt; wavelength(SDSS_u()) isa Vector{&lt;:Quantity}
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L132-L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.throughput"><a class="docstring-binding" href="#PhotometricFilters.throughput"><code>PhotometricFilters.throughput</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">throughput(f::AbstractFilter)</code></pre><p>Returns the throughput vector of the filter transmission curve (no units).</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: SDSS_u, throughput

julia&gt; throughput(SDSS_u()) isa Vector{&lt;:Number}
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L146-L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.detector_type"><a class="docstring-binding" href="#PhotometricFilters.detector_type"><code>PhotometricFilters.detector_type</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">detector_type(f::AbstractFilter)</code></pre><p>Return an instance of <code>PhotometricFilters.Energy</code> if the filter is defined for energy-counting detectors or <code>PhotometricFilters.Photon</code> for photon-counting detectors.</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: SDSS_u, detector_type, Photon

julia&gt; detector_type(SDSS_u()) === Photon()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L158-L167">source</a></section></details></article><p>Users can construct their own filter curvers from raw data using this type.</p><h2 id="Accessing-Filter-Curves"><a class="docs-heading-anchor" href="#Accessing-Filter-Curves">Accessing Filter Curves</a><a id="Accessing-Filter-Curves-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-Filter-Curves" title="Permalink"></a></h2><p>We provide a modest collection of filter curves through a data dependency. The available filter curves are accessible via the <code>FILTER_NAMES</code> module constant,</p><pre><code class="language-julia hljs">using PhotometricFilters
PhotometricFilters.FILTER_NAMES |&gt; println</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[&quot;2MASS_H&quot;, &quot;2MASS_J&quot;, &quot;2MASS_Ks&quot;, &quot;CFHT_CFH12K_CFH7406&quot;, &quot;CFHT_CFH12K_CFH7504&quot;, &quot;CFHT_MEGAPRIME_CFH7605&quot;, &quot;CFHT_MEGAPRIME_CFH7701&quot;, &quot;CFHT_MEGAPRIME_CFH7803&quot;, &quot;CFHT_MEGAPRIME_CFH9301&quot;, &quot;CFHT_MEGAPRIME_CFH9401&quot;, &quot;CFHT_MEGAPRIME_CFH9601&quot;, &quot;CFHT_MEGAPRIME_CFH9701&quot;, &quot;CFHT_MEGAPRIME_CFH9702&quot;, &quot;CFHT_MEGAPRIME_CFH9801&quot;, &quot;CFHT_WIRCAM_CFH8002&quot;, &quot;CFHT_WIRCAM_CFH8101&quot;, &quot;CFHT_WIRCAM_CFH8102&quot;, &quot;CFHT_WIRCAM_CFH8103&quot;, &quot;CFHT_WIRCAM_CFH8104&quot;, &quot;CFHT_WIRCAM_CFH8201&quot;, &quot;CFHT_WIRCAM_CFH8202&quot;, &quot;CFHT_WIRCAM_CFH8203&quot;, &quot;CFHT_WIRCAM_CFH8204&quot;, &quot;CFHT_WIRCAM_CFH8301&quot;, &quot;CFHT_WIRCAM_CFH8302&quot;, &quot;CFHT_WIRCAM_CFH8303&quot;, &quot;CFHT_WIRCAM_CFH8304&quot;, &quot;CFHT_WIRCAM_CFH8305&quot;, &quot;GALEX_FUV&quot;, &quot;GALEX_NUV&quot;, &quot;GROUND_BESSELL_H&quot;, &quot;GROUND_BESSELL_J&quot;, &quot;GROUND_BESSELL_K&quot;, &quot;GROUND_COUSINS_I&quot;, &quot;GROUND_COUSINS_R&quot;, &quot;GROUND_JOHNSON_B&quot;, &quot;GROUND_JOHNSON_U&quot;, &quot;GROUND_JOHNSON_V&quot;, &quot;GaiaDR2_BP&quot;, &quot;GaiaDR2_G&quot;, &quot;GaiaDR2_RP&quot;, &quot;GaiaDR2_weiler_BPbright&quot;, &quot;GaiaDR2_weiler_BPfaint&quot;, &quot;GaiaDR2_weiler_G&quot;, &quot;GaiaDR2_weiler_RP&quot;, &quot;GaiaDR2v2_BP&quot;, &quot;GaiaDR2v2_G&quot;, &quot;GaiaDR2v2_RP&quot;, &quot;Gaia_BP&quot;, &quot;Gaia_G&quot;, &quot;Gaia_MAW_BP_bright&quot;, &quot;Gaia_MAW_BP_faint&quot;, &quot;Gaia_MAW_G&quot;, &quot;Gaia_MAW_RP&quot;, &quot;Gaia_RP&quot;, &quot;Gaia_rvs&quot;, &quot;HERSCHEL_PACS_BLUE&quot;, &quot;HERSCHEL_PACS_GREEN&quot;, &quot;HERSCHEL_PACS_RED&quot;, &quot;HERSCHEL_SPIRE_PLW&quot;, &quot;HERSCHEL_SPIRE_PLW_EXT&quot;, &quot;HERSCHEL_SPIRE_PMW&quot;, &quot;HERSCHEL_SPIRE_PSW&quot;, &quot;HERSCHEL_SPIRE_PSW_EXT&quot;, &quot;HST_ACS_HRC_F220W&quot;, &quot;HST_ACS_HRC_F250W&quot;, &quot;HST_ACS_HRC_F330W&quot;, &quot;HST_ACS_HRC_F344N&quot;, &quot;HST_ACS_HRC_F435W&quot;, &quot;HST_ACS_HRC_F475W&quot;, &quot;HST_ACS_HRC_F502N&quot;, &quot;HST_ACS_HRC_F550M&quot;, &quot;HST_ACS_HRC_F555W&quot;, &quot;HST_ACS_HRC_F606W&quot;, &quot;HST_ACS_HRC_F625W&quot;, &quot;HST_ACS_HRC_F658N&quot;, &quot;HST_ACS_HRC_F660N&quot;, &quot;HST_ACS_HRC_F775W&quot;, &quot;HST_ACS_HRC_F814W&quot;, &quot;HST_ACS_HRC_F850LP&quot;, &quot;HST_ACS_HRC_F892N&quot;, &quot;HST_ACS_WFC_F435W&quot;, &quot;HST_ACS_WFC_F475W&quot;, &quot;HST_ACS_WFC_F502N&quot;, &quot;HST_ACS_WFC_F550M&quot;, &quot;HST_ACS_WFC_F555W&quot;, &quot;HST_ACS_WFC_F606W&quot;, &quot;HST_ACS_WFC_F625W&quot;, &quot;HST_ACS_WFC_F658N&quot;, &quot;HST_ACS_WFC_F660N&quot;, &quot;HST_ACS_WFC_F775W&quot;, &quot;HST_ACS_WFC_F814W&quot;, &quot;HST_ACS_WFC_F850LP&quot;, &quot;HST_ACS_WFC_F892N&quot;, &quot;HST_NIC2_F110W&quot;, &quot;HST_NIC2_F160W&quot;, &quot;HST_NIC2_F205W&quot;, &quot;HST_NIC3_F108N&quot;, &quot;HST_NIC3_F110W&quot;, &quot;HST_NIC3_F113N&quot;, &quot;HST_NIC3_F150W&quot;, &quot;HST_NIC3_F160W&quot;, &quot;HST_NIC3_F164N&quot;, &quot;HST_NIC3_F166N&quot;, &quot;HST_NIC3_F175W&quot;, &quot;HST_NIC3_F187N&quot;, &quot;HST_NIC3_F190N&quot;, &quot;HST_NIC3_F196N&quot;, &quot;HST_NIC3_F200N&quot;, &quot;HST_NIC3_F205M&quot;, &quot;HST_NIC3_F212N&quot;, &quot;HST_NIC3_F215N&quot;, &quot;HST_NIC3_F222M&quot;, &quot;HST_NIC3_F240M&quot;, &quot;HST_WFC3_F098M&quot;, &quot;HST_WFC3_F105W&quot;, &quot;HST_WFC3_F110W&quot;, &quot;HST_WFC3_F125W&quot;, &quot;HST_WFC3_F126N&quot;, &quot;HST_WFC3_F127M&quot;, &quot;HST_WFC3_F128N&quot;, &quot;HST_WFC3_F130N&quot;, &quot;HST_WFC3_F132N&quot;, &quot;HST_WFC3_F139M&quot;, &quot;HST_WFC3_F140W&quot;, &quot;HST_WFC3_F153M&quot;, &quot;HST_WFC3_F160W&quot;, &quot;HST_WFC3_F164N&quot;, &quot;HST_WFC3_F167N&quot;, &quot;HST_WFC3_F200LP&quot;, &quot;HST_WFC3_F218W&quot;, &quot;HST_WFC3_F225W&quot;, &quot;HST_WFC3_F275W&quot;, &quot;HST_WFC3_F280N&quot;, &quot;HST_WFC3_F300X&quot;, &quot;HST_WFC3_F336W&quot;, &quot;HST_WFC3_F343N&quot;, &quot;HST_WFC3_F350LP&quot;, &quot;HST_WFC3_F373N&quot;, &quot;HST_WFC3_F390M&quot;, &quot;HST_WFC3_F390W&quot;, &quot;HST_WFC3_F395N&quot;, &quot;HST_WFC3_F410M&quot;, &quot;HST_WFC3_F438W&quot;, &quot;HST_WFC3_F467M&quot;, &quot;HST_WFC3_F469N&quot;, &quot;HST_WFC3_F475W&quot;, &quot;HST_WFC3_F475X&quot;, &quot;HST_WFC3_F487N&quot;, &quot;HST_WFC3_F502N&quot;, &quot;HST_WFC3_F547M&quot;, &quot;HST_WFC3_F555W&quot;, &quot;HST_WFC3_F600LP&quot;, &quot;HST_WFC3_F606W&quot;, &quot;HST_WFC3_F621M&quot;, &quot;HST_WFC3_F625W&quot;, &quot;HST_WFC3_F631N&quot;, &quot;HST_WFC3_F645N&quot;, &quot;HST_WFC3_F656N&quot;, &quot;HST_WFC3_F657N&quot;, &quot;HST_WFC3_F658N&quot;, &quot;HST_WFC3_F665N&quot;, &quot;HST_WFC3_F673N&quot;, &quot;HST_WFC3_F680N&quot;, &quot;HST_WFC3_F689M&quot;, &quot;HST_WFC3_F763M&quot;, &quot;HST_WFC3_F775W&quot;, &quot;HST_WFC3_F814W&quot;, &quot;HST_WFC3_F845M&quot;, &quot;HST_WFC3_F850LP&quot;, &quot;HST_WFC3_F953N&quot;, &quot;HST_WFC3_FQ232N&quot;, &quot;HST_WFC3_FQ243N&quot;, &quot;HST_WFC3_FQ378N&quot;, &quot;HST_WFC3_FQ387N&quot;, &quot;HST_WFC3_FQ422M&quot;, &quot;HST_WFC3_FQ436N&quot;, &quot;HST_WFC3_FQ437N&quot;, &quot;HST_WFC3_FQ492N&quot;, &quot;HST_WFC3_FQ508N&quot;, &quot;HST_WFC3_FQ575N&quot;, &quot;HST_WFC3_FQ619N&quot;, &quot;HST_WFC3_FQ634N&quot;, &quot;HST_WFC3_FQ672N&quot;, &quot;HST_WFC3_FQ674N&quot;, &quot;HST_WFC3_FQ727N&quot;, &quot;HST_WFC3_FQ750N&quot;, &quot;HST_WFC3_FQ889N&quot;, &quot;HST_WFC3_FQ906N&quot;, &quot;HST_WFC3_FQ924N&quot;, &quot;HST_WFC3_FQ937N&quot;, &quot;HST_WFPC2_F170W&quot;, &quot;HST_WFPC2_F218W&quot;, &quot;HST_WFPC2_F255W&quot;, &quot;HST_WFPC2_F300W&quot;, &quot;HST_WFPC2_F336W&quot;, &quot;HST_WFPC2_F439W&quot;, &quot;HST_WFPC2_F450W&quot;, &quot;HST_WFPC2_F555W&quot;, &quot;HST_WFPC2_F606W&quot;, &quot;HST_WFPC2_F622W&quot;, &quot;HST_WFPC2_F675W&quot;, &quot;HST_WFPC2_F791W&quot;, &quot;HST_WFPC2_F814W&quot;, &quot;HST_WFPC2_F850LP&quot;, &quot;JWST_NIRCAM_F070W&quot;, &quot;JWST_NIRCAM_F090W&quot;, &quot;JWST_NIRCAM_F115W&quot;, &quot;JWST_NIRCAM_F140M&quot;, &quot;JWST_NIRCAM_F150W&quot;, &quot;JWST_NIRCAM_F150W2&quot;, &quot;JWST_NIRCAM_F162M&quot;, &quot;JWST_NIRCAM_F164N&quot;, &quot;JWST_NIRCAM_F182M&quot;, &quot;JWST_NIRCAM_F187N&quot;, &quot;JWST_NIRCAM_F200W&quot;, &quot;JWST_NIRCAM_F210M&quot;, &quot;JWST_NIRCAM_F212N&quot;, &quot;JWST_NIRCAM_F250M&quot;, &quot;JWST_NIRCAM_F277W&quot;, &quot;JWST_NIRCAM_F300M&quot;, &quot;JWST_NIRCAM_F322W2&quot;, &quot;JWST_NIRCAM_F323N&quot;, &quot;JWST_NIRCAM_F335M&quot;, &quot;JWST_NIRCAM_F356W&quot;, &quot;JWST_NIRCAM_F360M&quot;, &quot;JWST_NIRCAM_F405N&quot;, &quot;JWST_NIRCAM_F410M&quot;, &quot;JWST_NIRCAM_F430M&quot;, &quot;JWST_NIRCAM_F444W&quot;, &quot;JWST_NIRCAM_F460M&quot;, &quot;JWST_NIRCAM_F466N&quot;, &quot;JWST_NIRCAM_F470N&quot;, &quot;JWST_NIRCAM_F480M&quot;, &quot;KEPLER_Kp&quot;, &quot;NGTS_I&quot;, &quot;PS1_g&quot;, &quot;PS1_i&quot;, &quot;PS1_r&quot;, &quot;PS1_w&quot;, &quot;PS1_y&quot;, &quot;PS1_z&quot;, &quot;SDSS_g&quot;, &quot;SDSS_i&quot;, &quot;SDSS_r&quot;, &quot;SDSS_u&quot;, &quot;SDSS_z&quot;, &quot;SPITZER_IRAC_36&quot;, &quot;SPITZER_IRAC_45&quot;, &quot;SPITZER_IRAC_58&quot;, &quot;SPITZER_IRAC_80&quot;, &quot;STROMGREN_b&quot;, &quot;STROMGREN_u&quot;, &quot;STROMGREN_v&quot;, &quot;STROMGREN_y&quot;, &quot;TESS&quot;, &quot;TYCHO_B_MvB&quot;, &quot;TYCHO_V_MvB&quot;, &quot;WISE_RSR_W1&quot;, &quot;WISE_RSR_W2&quot;, &quot;WISE_RSR_W3&quot;, &quot;WISE_RSR_W4&quot;, &quot;ZTF_g&quot;, &quot;ZTF_i&quot;, &quot;ZTF_r&quot;]</code></pre><p>These included filter curves can be accessed like so,</p><pre><code class="language-julia hljs">using PhotometricFilters: SDSS_u, SDSS_g, SDSS_r, SDSS_i, SDSS_z, fwhm
filts = [SDSS_u(), SDSS_g(), SDSS_r(), SDSS_i(), SDSS_z()]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{PhotometricFilter{Float64, Vector{Unitful.Quantity{Float64, ùêã, Unitful.FreeUnits{(√Ö,), ùêã, nothing}}}, PhotometricFilters.Photon, Vector{Float64}, String, Interpolations.FilledExtrapolation{Float64, 1, Interpolations.GriddedInterpolation{Float64, 1, Vector{Float64}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Tuple{Vector{Unitful.Quantity{Float64, ùêã, Unitful.FreeUnits{(√Ö,), ùêã, nothing}}}}}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Float64}}}:
 SDSS_u
 SDSS_g
 SDSS_r
 SDSS_i
 SDSS_z</code></pre><p><strong>NOTE THAT THESE INCLUDED FILTER CURVES ARE NOT GUARANTEED TO BE UP-TO-DATE.</strong> If you are using a filter/instrument that may have recently had its filter curves updated (e.g., JWST/NIRCAM), you should use our SVO query interface to make sure you get the most up-to-date filter curves. SVO also provides additional metadata that is useful for some applications (e.g., filter zeropoints). If you know the SVO-designated name of the filter you want, you can use <a href="#PhotometricFilters.get_filter"><code>get_filter</code></a> to retrieve its transmission data, which returns an instance of <a href="#PhotometricFilters.SVOFilter"><code>SVOFilter</code></a>.</p><article><details class="docstring" open="true"><summary id="PhotometricFilters.get_filter"><a class="docstring-binding" href="#PhotometricFilters.get_filter"><code>PhotometricFilters.get_filter</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_filter(filtername::AbstractString, magsys::Symbol=:Vega)</code></pre><p>Query the online <a href="http://svo2.cab.inta-csic.es/theory/fps">SVO filter service</a> for data on a photometric filter.</p><p><strong>Arguments</strong></p><ul><li><code>filtername::AbstractString</code>: The desired filter ID, in the correct SVO specification (e.g., <code>&quot;2MASS/2MASS.J&quot;</code>).</li><li><code>magsys::Symbol</code>: Desired magnitude system for associated metadata (e.g., <code>&quot;ZeroPoint&quot;</code>). Can be any of <code>(:AB, :Vega, :ST)</code>. SVO uses Vega by default, so we mirror that choice here.</li></ul><p><strong>Returns</strong></p><p>An <a href="#PhotometricFilters.SVOFilter"><code>SVOFilter</code></a> instance containing the results of the query.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: get_filter

julia&gt; filt = get_filter(&quot;2MASS/2MASS.J&quot;, :Vega)
107-element PhotometricFilters.SVOFilter{PhotometricFilter{Float64}}: 2MASS/2MASS.J
 reference wave.: 12350.0 √Ö
 min. wave.: 10806.470589792389 √Ö
 max. wave.: 14067.974683578484 √Ö
 effective wave.: 12284.994608629975 √Ö
 mean wave.: 12410.5170694321 √Ö
 central wave.: 12390.584132888223 √Ö
 pivot wave.: 12393.093155655275 √Ö
 eff. width: 1624.3245065600008 √Ö
 fwhm: 2149.1445403830403 √Ö</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/svo.jl#L58-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.SVOFilter"><a class="docstring-binding" href="#PhotometricFilters.SVOFilter"><code>PhotometricFilters.SVOFilter</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SVOFilter(filter::PhotometricFilter, metadata) &lt;: AbstractFilter</code></pre><p>Type for containing the photometric filter information returned by the SVO filter service. A result of this type is returned by <a href="#PhotometricFilters.get_filter"><code>get_filter</code></a>. Contains two fields:</p><ul><li><code>filter</code> is a <a href="#PhotometricFilters.PhotometricFilter"><code>PhotometricFilter</code></a> type that is used to support common operations.</li><li><code>metadata</code> is a dictionary (currently an <code>OrderedCollections.OrderedDict</code>) that contains the metadata returned by SVO.</li></ul><p>These fields are considered internal (subject to change) and users should interact with instances of this type via the public accessor methods instead. Example usage is below.</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: get_filter, SVOFilter, PhotometricFilter

julia&gt; filt = get_filter(&quot;2MASS/2MASS.J&quot;, :Vega);

julia&gt; filt isa SVOFilter
true

julia&gt; PhotometricFilter(filt) isa PhotometricFilter # Access simpler PhotometricFilter type
true

julia&gt; Dict(filt) isa Dict # Retrieve full metadata dictionary
true

julia&gt; filt[&quot;ZeroPoint&quot;] # Can retrieve metadata directly
1594.0 Jy

julia&gt; filtername(filt) # `filtername`, `detector_type`, `wavelength`, `throughput` all work
&quot;2MASS/2MASS.J&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/svo.jl#L13-L39">source</a></section></details></article><p>If you&#39;d like to perform a search on the filters available through the SVO filter service, you can use <a href="#PhotometricFilters.query_filters"><code>query_filters</code></a>.</p><article><details class="docstring" open="true"><summary id="PhotometricFilters.query_filters"><a class="docstring-binding" href="#PhotometricFilters.query_filters"><code>PhotometricFilters.query_filters</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">query_filters(; queries...)</code></pre><p>Queries the filters available from the SVO filter service with search parameters and returns a table of the filters found.</p><p>The available search parameters can be found with <a href="#PhotometricFilters.get_metadata"><code>PhotometricFilters.get_metadata</code></a>. The following should be available in general:</p><ul><li><code>WavelengthRef</code>: Tuple of Numbers</li><li><code>WavelengthMean</code>: Tuple of Numbers</li><li><code>WavelengthEff</code>: Tuple of Numbers</li><li><code>WavelengthMin</code>: Tuple of Numbers</li><li><code>WavelengthMax</code>: Tuple of Numbers</li><li><code>WidthEff</code>: Tuple of Numbers</li><li><code>FWHM</code>: Tuple of Numbers</li><li><code>Instrument</code>: String</li><li><code>Facility</code>: String</li><li><code>PhotSystem</code>: String</li></ul><p>The returned table is a <code>DataFrame</code> from the <a href="https://github.com/JuliaData/DataFrames.jl"><code>DataFrames</code></a> package with all the columns of the response VOTable.</p><p>The filter information and transmission data can be obtained by calling <a href="#PhotometricFilters.get_filter"><code>get_filter</code></a> with the ID obtained from the <code>filterID</code> column.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: query_filters, SVOFilter

julia&gt; using DataFrames: DataFrame

julia&gt; df = query_filters(; Facility=&quot;SLOAN&quot;, WavelengthEff=(1000, 5000));

julia&gt; df isa DataFrame
true

julia&gt; id = df.filterID[3]
&quot;SLOAN/SDSS.g&quot;

julia&gt; get_filter(id) isa SVOFilter
true</code></pre><pre><code class="language-julia hljs"># Other examples for querying
query_filters(; Facility=&quot;SLOAN&quot;) # all filters from a given facility
query_filters(; Instrument=&quot;BUSCA&quot;, WavelengthEff=(1000u&quot;angstrom&quot;, 5000u&quot;angstrom&quot;)) # Unitful wavelengths</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/svo.jl#L322-L368">source</a></section></details></article><h3 id="Interacting-with-the-Filter-Cache"><a class="docs-heading-anchor" href="#Interacting-with-the-Filter-Cache">Interacting with the Filter Cache</a><a id="Interacting-with-the-Filter-Cache-1"></a><a class="docs-heading-anchor-permalink" href="#Interacting-with-the-Filter-Cache" title="Permalink"></a></h3><p>After you first access a filter with <a href="#PhotometricFilters.get_filter"><code>get_filter</code></a>, it is cached to disk for future use. It is expected that users should not typically have to manually interact with the cache. As such, the cache-related utilities discussed here are not exported from the package and must be explicitly imported (e.g., <code>using PhotometricFilters: update_filters; update_filters()</code>) or used via the qualified syntax (e.g., <code>using PhotometricFilters; PhotometricFilters.update_filters()</code>).</p><p>You can list the currently cached filters with <a href="#PhotometricFilters.cached_filters"><code>PhotometricFilters.cached_filters</code></a>. To update cached filters, ensuring you have the most up-to-date data, you can use <a href="#PhotometricFilters.update_filter"><code>PhotometricFilters.update_filter</code></a>. You can delete filters from the cache with <a href="#PhotometricFilters.clear_filter"><code>PhotometricFilters.clear_filter</code></a>.</p><article><details class="docstring" open="true"><summary id="PhotometricFilters.cached_filters"><a class="docstring-binding" href="#PhotometricFilters.cached_filters"><code>PhotometricFilters.cached_filters</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cached_filters()</code></pre><p>Returns a <code>Vector{Tuple{String, Symbol}}</code> containing the filter identifier and magnitude system for each SVO filter in the cache.</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: cached_filters, get_filter

julia&gt; get_filter(&quot;2MASS/2MASS.J&quot;, :Vega); # Load SVO filter, will be cached if not already

julia&gt; (&quot;2MASS/2MASS.J&quot;, :Vega) in cached_filters() # Check that filter is in the cache
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/svo.jl#L150-L162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.update_filter"><a class="docstring-binding" href="#PhotometricFilters.update_filter"><code>PhotometricFilters.update_filter</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">update_filter(f::AbstractString, magsys::Symbol)</code></pre><p>Reacquires filter with SVO identifier <code>f</code> in the magnitude system <code>magsys</code> from SVO and saves it into the cache. Returns the updated filter.</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: cached_filters, update_filter, SVOFilter

julia&gt; get_filter(&quot;2MASS/2MASS.J&quot;, :Vega); # Load SVO filter, will be cached if not already

julia&gt; update_filter(&quot;2MASS/2MASS.J&quot;, :Vega) isa SVOFilter # Updates cached file, returns filter
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/svo.jl#L168-L180">source</a></section><section><div><pre><code class="language-julia hljs">update_filter()</code></pre><p>When called with no arguments, updates all filters in the cache. Returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/svo.jl#L198-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.clear_filter"><a class="docstring-binding" href="#PhotometricFilters.clear_filter"><code>PhotometricFilters.clear_filter</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">clear_filter(f::AbstractString, magsys::Symbol)</code></pre><p>Deletes filter <code>f</code> in magnitude system <code>magsys</code> from the cache.</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: get_filter, clear_filter, cached_filters

julia&gt; get_filter(&quot;2MASS/2MASS.J&quot;, :Vega); # Ensure filter in cache

julia&gt; clear_filter(&quot;2MASS/2MASS.J&quot;, :Vega) # Remove filter from cache

julia&gt; (&quot;2MASS/2MASS.J&quot;, :Vega) in cached_filters() # Check that filter was removed from cache
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/svo.jl#L204-L218">source</a></section><section><div><pre><code class="language-julia hljs">clear_filter()</code></pre><p>When called with no arguments, deletes all filters from the cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/svo.jl#L227-L230">source</a></section></details></article><p>We include functions for performing many common operations on photometric filters, summarized below.</p><h2 id="Applying-Filter-Curves-to-Spectra"><a class="docs-heading-anchor" href="#Applying-Filter-Curves-to-Spectra">Applying Filter Curves to Spectra</a><a id="Applying-Filter-Curves-to-Spectra-1"></a><a class="docs-heading-anchor-permalink" href="#Applying-Filter-Curves-to-Spectra" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PhotometricFilters.apply_throughput"><a class="docstring-binding" href="#PhotometricFilters.apply_throughput"><code>PhotometricFilters.apply_throughput</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">apply_throughput(f::AbstractFilter, wavelengths, flux)</code></pre><p>Use linear interpolation to map the wavelengths of the photometric filter <code>f</code> to the given <code>wavelengths</code> and apply the filter throughput to the <code>flux</code>. The provided <code>wavelengths</code> and those of the filter must be compatible. This means if one has units, the other one needs units, too.</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: SDSS_u, wave_unit, apply_throughput

julia&gt; f = SDSS_u();

julia&gt; Œª = 3000:4000
3000:4000

julia&gt; flux = fill(1.0, length(Œª)); # If `flux` is all `1`, `apply_throughput` reduces to `f` interpolated at `Œª`

julia&gt; apply_throughput(f, Œª, flux) == f(Œª)
true

julia&gt; Œª_u = Œª .* wave_unit # Can also put units on Œª
(3000:4000) √Ö

julia&gt; apply_throughput(f, Œª_u, flux) == f.(Œª_u)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L366-L390">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.apply_throughput!"><a class="docstring-binding" href="#PhotometricFilters.apply_throughput!"><code>PhotometricFilters.apply_throughput!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">apply_throughput!(f::AbstractFilter, wavelengths, flux, out)</code></pre><p>In-place version of <a href="#PhotometricFilters.apply_throughput"><code>apply_throughput</code></a> which modifies <code>out</code>. It should have a compatible element type with <code>flux</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L393-L397">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.mean_flux_density"><a class="docstring-binding" href="#PhotometricFilters.mean_flux_density"><code>PhotometricFilters.mean_flux_density</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mean_flux_density(filt::AbstractFilter, wavelengths, flux)</code></pre><p>Returns the mean flux density of a spectrum (defined by wavelengths <code>wavelengths</code> and fluxes <code>flux</code>) when integrated over the provided filter <code>filt</code>.</p><p>For photon counting detectors, this is</p><p class="math-container">\[\overline{f_\lambda} = \frac{\int_\lambda \lambda \, f_\lambda \, T(\lambda) \, d\lambda}{\int_\lambda \lambda \, T(\lambda) \, d\lambda}\]</p><p>which can also be interpreted as the mean photon rate density, while for energy counting detectors, this is</p><p class="math-container">\[\overline{f_\lambda} = \frac{\int_\lambda f_\lambda \, T(\lambda) \, d\lambda}{\int_\lambda T(\lambda) \, d\lambda}\]</p><p>which is essentially just the mean flux weighted by the filter throughput.</p><p>Below we show example usage that can be compared against <a href="https://github.com/mfouesneau/pyphot/blob/master/examples/Sun_Vega.ipynb">this example</a> from pyphot.</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: mean_flux_density, HST_WFC3_F110W, Vega

julia&gt; using Unitful, UnitfulAstro

julia&gt; v = Vega(&quot;alpha_lyr_stis_006&quot;);

julia&gt; mfd = mean_flux_density(HST_WFC3_F110W(), v.wave, v.flux);

julia&gt; isapprox(mfd, 4.082289e-10 * u&quot;erg/s/cm^2/angstrom&quot;; rtol=1e-3)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L403-L435">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.F_nu"><a class="docstring-binding" href="#PhotometricFilters.F_nu"><code>PhotometricFilters.F_nu</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">F_nu(F_lambda::SpectralFluxDensity, Œªref)
F_nu(F_lambda::SpectralFluxDensity, f::AbstractFilter)</code></pre><p>Convert a spectral flux density <code>F_lambda</code> into a spectral energy density. Assuming <code>F_lambda</code> in <em>erg / s / cm^2 / Angstrom</em>, and <code>F_nu</code> in <em>Jy</em>, this conversion is</p><p class="math-container">\[F_\nu = \frac{10^5}{10^{-8} \, c} \, \lambda^2_r \, F_\lambda\]</p><p>where <span>$c$</span> is the speed of light in <em>m/s</em> and <span>$\lambda_r$</span> is the reference wavelength (<code>Œªref</code>) in <em>Angstroms</em>. If providing an <a href="#PhotometricFilters.AbstractFilter"><code>AbstractFilter</code></a> as the second argument, the reference wavelength will be automatically computed with <a href="#PhotometricFilters.reference_wavelength"><code>reference_wavelength</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L469-L479">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.F_lambda"><a class="docstring-binding" href="#PhotometricFilters.F_lambda"><code>PhotometricFilters.F_lambda</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">F_lambda(F_nu::SpectralEnergyDensity, Œªref)
F_lambda(F_nu::SpectralEnergyDensity, f::AbstractFilter)</code></pre><p>Convert a spectral energy density <code>F_nu</code> into a spectral flux density. Assuming <code>F_nu</code> in <em>Jy</em> and <code>F_lambda</code> in <em>erg / s / cm^2 / Angstrom</em>, this conversion is</p><p class="math-container">\[F_\lambda = \frac{10^{-8} \, c}{10^5} \, \lambda^{-2}_r \, F_\nu\]</p><p>where <span>$c$</span> is the speed of light in <em>m/s</em> and <span>$\lambda_r$</span> is the reference wavelength (<code>Œªref</code>) in <em>Angstroms</em>. If providing an <a href="#PhotometricFilters.AbstractFilter"><code>AbstractFilter</code></a> as the second argument, the reference wavelength will be automatically computed with <a href="#PhotometricFilters.reference_wavelength"><code>reference_wavelength</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L484-L494">source</a></section></details></article><h2 id="Zero-Points"><a class="docs-heading-anchor" href="#Zero-Points">Zero Points</a><a id="Zero-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Zero-Points" title="Permalink"></a></h2><p>We utilize multiple dispatch to support dynamic calculation of zeropoints in the magnitude systems below.</p><article><details class="docstring" open="true"><summary id="PhotometricFilters.MagnitudeSystem"><a class="docstring-binding" href="#PhotometricFilters.MagnitudeSystem"><code>PhotometricFilters.MagnitudeSystem</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Abstract supertype for magnitude systems like <a href="#PhotometricFilters.AB"><code>AB</code></a>, <a href="#PhotometricFilters.ST"><code>ST</code></a>, and <a href="#PhotometricFilters.Vega"><code>Vega</code></a>. Subtypes should implement <a href="#PhotometricFilters.zeropoint_mag"><code>zeropoint_mag</code></a>, <a href="#PhotometricFilters.zeropoint_flux"><code>zeropoint_flux</code></a>, and <a href="#PhotometricFilters.zeropoint_Jy"><code>zeropoint_Jy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L29-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.AB"><a class="docstring-binding" href="#PhotometricFilters.AB"><code>PhotometricFilters.AB</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AB() &lt;: MagnitudeSystem</code></pre><p>Singleton struct representing the AB magnitude system. This system is defined such that</p><p class="math-container">\[m_\text{AB} = -2.5 \ \text{log} \left( \bar{f_ŒΩ} \right) - 48.60\]</p><p>when <span>$f_ŒΩ$</span> is in units of erg / s / cm^2 / Hz. This corresponds to a constant  <a href="#PhotometricFilters.zeropoint_Jy"><code>zeropoint_Jy</code></a> value in all filters of <code>exp10(48.6 / -2.5 + 23)</code> ‚âà 3631 Jy.</p><p>When passed to methods such as <a href="#PhotometricFilters.zeropoint_flux"><code>zeropoint_flux</code></a>, indicates that you wish to have the AB zeropoint flux returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L55-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.ST"><a class="docstring-binding" href="#PhotometricFilters.ST"><code>PhotometricFilters.ST</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ST() &lt;: MagnitudeSystem</code></pre><p>Singleton struct representing the ST magnitude system. This system is defined so that a source with uniform <span>$f_\lambda$</span> has identical magnitude in every filter.</p><p class="math-container">\[m_\text{ST} = -2.5 \ \text{log} \left( \bar{f_\lambda} \right) - 21.1\]</p><p>When passed to methods such as <a href="#PhotometricFilters.zeropoint_flux"><code>zeropoint_flux</code></a>, indicates that you wish to have the ST zeropoint flux returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L71-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.Vega"><a class="docstring-binding" href="#PhotometricFilters.Vega"><code>PhotometricFilters.Vega</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Vega(wave, flux, name::String) &lt;: MagnitudeSystem</code></pre><p>Struct for containing a Vega reference spectrum with wavelengths <code>wave</code> and flux values <code>flux</code>. <code>wave</code> should be provided in units of √Ö and  flux should be provided in <span>$f_Œª$</span> units of erg / s / cm^2 / Angstrom.</p><p>The Vega magnitude system is defined so that the star Alpha Lyr (i.e., Vega) has magnitude 0 in every filter.</p><p class="math-container">\[m_\text{Vega} = -2.5 \ \text{log} \left( \frac{\bar{f_\lambda}}{\bar{f_\lambda} \left( \text{Vega} \right)} \right)\]</p><p>When passed to methods such as <a href="#PhotometricFilters.zeropoint_flux"><code>zeropoint_flux</code></a>, indicates that you wish to have the Vega zeropoint flux returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L33-L48">source</a></section></details></article><p>Any reference spectrum hosted by <a href="https://ssb.stsci.edu/cdbs/calspec/">CALSPEC</a> can be used to construct an instance of <a href="#PhotometricFilters.Vega"><code>Vega</code></a> using the method below.</p><article><details class="docstring" open="true"><summary id="PhotometricFilters.Vega-Tuple{String}"><a class="docstring-binding" href="#PhotometricFilters.Vega-Tuple{String}"><code>PhotometricFilters.Vega</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Vega(name::String = &quot;alpha_lyr_stis_011&quot;)</code></pre><p>Loads the reference spectrum with filename <code>name</code> and returns an appropriate instance of <code>Vega</code> that can be used to compute zeropoints and magnitudes in the Vega magnitude system.</p><p>If the provided <code>name</code> is the full path to the existing file on disk, the spectrum is loaded from that file. Otherwise, it is downloaded from the <a href="https://www.stsci.edu/hst/instrumentation/reference-data-for-calibration-and-tools/astronomical-catalogs/calspec">CALSPEC database</a> of standard stars maintained by STScI. Files downloaded this way are cached for future use. Specifically, we draw from the extended catalog <a href="https://ssb.stsci.edu/cdbs/calspec/">here</a>. The CALSPEC catalog with the most recent reference spectrum for each star is located <a href="https://archive.stsci.edu/hlsps/reference-atlases/cdbs/current_calspec/">here</a>. Standard Vega spectra start with <code>&quot;alpha_lyr&quot;</code>. <code>name</code>s like <code>&quot;alpha_lyr_stis_XXX&quot;</code> are based on composites of calibrated stellar models and HST/STIS data, while <code>&quot;alpha_lyr_mod_XXX&quot;</code> are based on stellar models only.</p><p>Sometimes Vega is not used as the standard star for photometric systems even when the system follows the Vega magnitude convention. For example, in the near-IR Sirius is often used as the standard reference spectrum rather than Vega. This is the case for the definition of the <a href="https://jwst-docs.stsci.edu/jwst-near-infrared-camera/nircam-performance/nircam-absolute-flux-calibration-and-zeropoints#gsc.tab=0">JWST zeropoints</a>, which presently use the <code>&quot;sirius_stis_005.fits&quot;</code> CALSPEC spectrum as their standard. To load a different standard, simply provide the corresponding <code>name</code> to <code>Vega</code>. For example, to load the Sirius spectrum, use <code>Vega(&quot;sirius_stis_005&quot;)</code> (the <code>&quot;.fits&quot;</code> extension is optional).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/vega.jl#L4-L11">source</a></section></details></article><p>The list of available spectral standards can be retrieved with <a href="#PhotometricFilters.get_calspec_names"><code>PhotometricFilters.get_calspec_names</code></a>.</p><article><details class="docstring" open="true"><summary id="PhotometricFilters.get_calspec_names"><a class="docstring-binding" href="#PhotometricFilters.get_calspec_names"><code>PhotometricFilters.get_calspec_names</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_calspec_names([substring::AbstractString])</code></pre><p>Returns a list of the names of the available spectral standards that can be download from CALSPEC and used as a standard in the Vega magnitude system.</p><p>If the optional <code>substring::AbstractString</code> argument is provided, then the list of names is filtered to only include those that contain the provided substring.</p><p>This method is not currently exported.</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: Vega, get_calspec_names

julia&gt; names = get_calspec_names();

julia&gt; names isa Vector{String}
true

julia&gt; Vega(names[1]) isa Vega
true

julia&gt; vega_standards = get_calspec_names(&quot;alpha_lyr&quot;);

julia&gt; all(map(x -&gt; occursin(&quot;alpha_lyr&quot;, x), vega_standards))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/vega.jl#L31-L55">source</a></section></details></article><p>Zeropoints can be computed with methods below.</p><article><details class="docstring" open="true"><summary id="PhotometricFilters.zeropoint_flux"><a class="docstring-binding" href="#PhotometricFilters.zeropoint_flux"><code>PhotometricFilters.zeropoint_flux</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">zeropoint_flux(f::AbstractFilter, T::MagnitudeSystem)</code></pre><p>Returns the flux zero point of the filter <code>f</code> in magnitude system <code>T</code> in units of erg / s / cm^2 / Angstrom.</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: zeropoint_flux, AB, ST, Vega, HST_WFC3_F110W

julia&gt; using Unitful

julia&gt; isapprox(zeropoint_flux(HST_WFC3_F110W(), AB()), 8.159816925e-10 * u&quot;erg/s/cm^2/angstrom&quot;; rtol=1e-3)
true

julia&gt; isapprox(zeropoint_flux(HST_WFC3_F110W(), ST()), 3.6307805e-9 * u&quot;erg/s/cm^2/angstrom&quot;; rtol=1e-3)
true

julia&gt; isapprox(zeropoint_flux(HST_WFC3_F110W(), Vega(&quot;alpha_lyr_stis_006&quot;)), 4.082289e-10 * u&quot;erg/s/cm^2/angstrom&quot;; rtol=1e-3)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L524-L542">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.zeropoint_Jy"><a class="docstring-binding" href="#PhotometricFilters.zeropoint_Jy"><code>PhotometricFilters.zeropoint_Jy</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">zeropoint_Jy(f::AbstractFilter, T::MagnitudeSystem)</code></pre><p>Returns the flux zeropoint in Jansky in magnitude system <code>T</code>.</p><p>Note that for the <a href="#PhotometricFilters.AB"><code>AB</code></a> system, this is often approximated as 3631 Jy, following from the definition <span>$m_\text{AB} = -2.5 \, \text{log} \left( \bar{f_\nu} \right) - 48.6$</span> where <span>$\bar{f_\nu}$</span> is in units of erg / s / cm^2 / Hz. This can be solved for <span>$m_\text{AB} = 0$</span> to give <span>$\bar{f}_{\nu, 0} = 10^{\frac{48.6}{-2.5}}$</span> which is approximately <span>$3.631 \times 10^{-20}$</span> erg / s / cm^2 / Hz, or ‚âà 3631 Jy. This function returns the exact value.</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: zeropoint_Jy, AB, ST, Vega, HST_WFC3_F110W

julia&gt; using Unitful, UnitfulAstro

julia&gt; isapprox(zeropoint_Jy(HST_WFC3_F110W(), AB()), 3630.78054 * u&quot;Jy&quot;; rtol=1e-3)
true

julia&gt; isapprox(zeropoint_Jy(HST_WFC3_F110W(), ST()), 16155.46954* u&quot;Jy&quot;; rtol=1e-3)
true

julia&gt; isapprox(zeropoint_Jy(HST_WFC3_F110W(), Vega(&quot;alpha_lyr_stis_006&quot;)), 1816.43597 * u&quot;Jy&quot;; rtol=1e-3)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L499-L519">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.zeropoint_mag"><a class="docstring-binding" href="#PhotometricFilters.zeropoint_mag"><code>PhotometricFilters.zeropoint_mag</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">zeropoint_mag(f::AbstractFilter, T::MagnitudeSystem)</code></pre><p>Returns the magnitude zero point of the filter <code>f</code> in the magnitude system <code>T</code>. This is used by the <a href="#PhotometricFilters.magnitude"><code>magnitude</code></a> method to calculate magnitudes from spectra in units of <a href="#PhotometricFilters.F_lambda"><code>F_lambda</code></a> as</p><p class="math-container">\[m_{\text{AB}} = -2.5 * \text{log} \left( \bar{f_\lambda} \right) - \text{Zpt}\]</p><p>For the <a href="#PhotometricFilters.ST"><code>ST</code></a> magnitude system, this is always equal to 21.1 by definition.</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: zeropoint_mag, AB, ST, Vega, HST_WFC3_F110W

julia&gt; isapprox(zeropoint_mag(HST_WFC3_F110W(), AB()), 22.7207989; rtol=1e-3)
true

julia&gt; isapprox(float(zeropoint_mag(HST_WFC3_F110W(), ST())), 21.1; rtol=1e-3)
true

julia&gt; isapprox(zeropoint_mag(HST_WFC3_F110W(), Vega(&quot;alpha_lyr_stis_006&quot;)), 23.4727487; rtol=1e-3)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L547-L569">source</a></section></details></article><h2 id="Synthetic-Photometry"><a class="docs-heading-anchor" href="#Synthetic-Photometry">Synthetic Photometry</a><a id="Synthetic-Photometry-1"></a><a class="docs-heading-anchor-permalink" href="#Synthetic-Photometry" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PhotometricFilters.magnitude"><a class="docstring-binding" href="#PhotometricFilters.magnitude"><code>PhotometricFilters.magnitude</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">magnitude(f::AbstractFilter, T::MagnitudeSystem, wavelengths, flux)</code></pre><p>Calculates the magnitude in the given filter <code>f</code> in the magnitude system <code>T</code> from a spectrum defined by arrays <code>wavelengths</code> and <code>flux</code>, both of which must have valid Unitful units.</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: magnitude, Vega, ST, AB, HST_WFC3_F110W

julia&gt; v = Vega(&quot;alpha_lyr_stis_006&quot;);

julia&gt; isapprox(magnitude(HST_WFC3_F110W(), AB(), v.wave, v.flux), 0.7519497; rtol=1e-3)
true

julia&gt; isapprox(magnitude(HST_WFC3_F110W(), ST(), v.wave, v.flux), 2.372748728; rtol=1e-3)
true

julia&gt; isapprox(magnitude(HST_WFC3_F110W(), v, v.wave, v.flux), 0; rtol=1e-3)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L574-L592">source</a></section><section><div><pre><code class="language-julia hljs">magnitude(fbar, zeropoint)</code></pre><p>Calculates a magnitude from a mean flux density <code>fbar</code> (a plain number, in units of erg / s / cm^2 / Angstrom; see <a href="#PhotometricFilters.mean_flux_density"><code>mean_flux_density</code></a>) and a magnitude zeropoint <code>zeropoint</code> (see <a href="#PhotometricFilters.zeropoint_mag"><code>zeropoint_mag</code></a>).</p><pre><code class="language-julia-repl hljs">julia&gt; using PhotometricFilters: magnitude

julia&gt; magnitude(1e-10, 22.0) == -2.5 * log10(1e-10) - 22.0
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L597-L607">source</a></section></details></article><h2 id="Statistics"><a class="docs-heading-anchor" href="#Statistics">Statistics</a><a id="Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Statistics" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PhotometricFilters.reference_wavelength"><a class="docstring-binding" href="#PhotometricFilters.reference_wavelength"><code>PhotometricFilters.reference_wavelength</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">reference_wavelength(f::AbstractFilter)</code></pre><p>Returns the reference wavelength of the filter <code>f</code>, used for conversions of the flux and for determination of magnitudes.</p><p>By default the pivot wavelength is returned (<a href="#PhotometricFilters.pivot_wavelength"><code>pivot_wavelength</code></a>), but filter providers sometimes provide their own specified values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L231-L237">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.mean_wavelength"><a class="docstring-binding" href="#PhotometricFilters.mean_wavelength"><code>PhotometricFilters.mean_wavelength</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mean_wavelength(f::AbstractFilter)</code></pre><p>Returns the mean wavelength of the filter <code>f</code>, defined as</p><p class="math-container">\[\frac{\int \lambda \, T(\lambda) \, d\lambda}{\int T(\lambda) \, d\lambda}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L240-L248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.central_wavelength"><a class="docstring-binding" href="#PhotometricFilters.central_wavelength"><code>PhotometricFilters.central_wavelength</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">central_wavelength(f::AbstractFilter)</code></pre><p>Returns the central wavelength of the filter <code>f</code>, defined as the central wavelength between the two wavelengths used for the FWHM (<a href="#PhotometricFilters.fwhm"><code>fwhm</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L256-L260">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.effective_wavelength"><a class="docstring-binding" href="#PhotometricFilters.effective_wavelength"><code>PhotometricFilters.effective_wavelength</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">effective_wavelength(f::AbstractFilter, v::Vega = Vega())</code></pre><p>Returns the effective wavelength of the filter <code>f</code> using the Vega spectrum contained in <code>v</code> as a standard. Defined as</p><p class="math-container">\[\frac{\int \lambda \, T(\lambda) \text{Vg}(\lambda) \, d\lambda}{\int T(\lambda) \text{Vg}(\lambda) \, d\lambda}\]</p><p>where <span>$T(\lambda)$</span> is the filter transmission at wavelength <span>$\lambda$</span> and <span>$\text{Vg}(\lambda)$</span> is the spectrum of Vega.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L183-L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.pivot_wavelength"><a class="docstring-binding" href="#PhotometricFilters.pivot_wavelength"><code>PhotometricFilters.pivot_wavelength</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pivot_wavelength(f::AbstractFilter)</code></pre><p>Returns the pivot wavelength of the filter <code>f</code>, defined for filters with <code>Energy</code> detector types as</p><p class="math-container">\[\sqrt{ \frac{\int T(\lambda) \, d\lambda}{\int T(\lambda) / \lambda^2 \, d\lambda} }\]</p><p>For filters with <code>Photon</code> detector types, <span>$\lambda \, T(\lambda)$</span> is substituted for <span>$T(\lambda)$</span> in the above expression.</p><p>Internally integration is carried out using trapezoidal integration. It can be convenient to think of this as the &quot;center of mass&quot; of the filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L202-L214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.min_wave"><a class="docstring-binding" href="#PhotometricFilters.min_wave"><code>PhotometricFilters.min_wave</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">min_wave(f::AbstractFilter; level=0.01)</code></pre><p>Returns the shortest wavelength at which the filter transmission is equal to <code>level * maximum(transmission)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L287-L291">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.max_wave"><a class="docstring-binding" href="#PhotometricFilters.max_wave"><code>PhotometricFilters.max_wave</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">max_wave(f::AbstractFilter; level=0.01)</code></pre><p>Returns the longest wavelength at which the filter transmission is equal to <code>level * maximum(transmission)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L304-L308">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.fwhm"><a class="docstring-binding" href="#PhotometricFilters.fwhm"><code>PhotometricFilters.fwhm</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fwhm(f::AbstractFilter)</code></pre><p>Returns the difference between the furthest two wavelengths for which the filter transmission is equal to half its maximum value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L321-L325">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.width"><a class="docstring-binding" href="#PhotometricFilters.width"><code>PhotometricFilters.width</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">width(f::AbstractFilter)</code></pre><p>Returns the effective width of the filter, defined as the horizontal size of a rectangle with height equal to the maximum transmission of the filter such that the area of the rectangle is equal to the area under the filter transmission curve. This is calculated as</p><p class="math-container">\[\frac{\int T(\lambda) \, d\lambda}{\text{max}(T(\lambda))}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L352-L360">source</a></section></details></article><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PhotometricFilters.AbstractFilter"><a class="docstring-binding" href="#PhotometricFilters.AbstractFilter"><code>PhotometricFilters.AbstractFilter</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractFilter{T}</code></pre><p>Abstract supertype for representing photometric filters. Most functions provided by this package (e.g., <a href="#PhotometricFilters.effective_wavelength"><code>effective_wavelength</code></a> and similar methods) are designed to work with any subtype of <code>AbstractFilter</code> so long as a minimal API is defined for new subtypes. The methods that should be implemented for new types to conform to this API are summarized below:</p><ul><li><a href="#PhotometricFilters.filtername"><code>filtername(f::NewType)</code></a> should return a string indicating a human-readable name for the filter (e.g., &quot;SDSS_u&quot;).</li><li><a href="#PhotometricFilters.wavelength"><code>wavelength(f::NewType)</code></a> should return the wavelength vector of the filter transmission curve with proper <code>Unitful.jl</code> units.</li><li><a href="#PhotometricFilters.throughput"><code>throughput(f::NewType)</code></a> should return the throughput vector of the filter transmission curve (no units).</li><li><a href="#PhotometricFilters.detector_type"><code>detector_type(f::NewType)</code></a> should return an instance of <code>PhotometricFilters.Energy</code> if the filter is defined for energy-counting detectors or <code>PhotometricFilters.Photon</code> for photon-counting detectors.</li></ul><p>Additionally, all subtypes should support filter interpolation at user-defined wavelengths with a call signature <code>(f::NewType)(wavelengths)</code>. To support this, new types should implement a method like <code>(f::PhotometricFilter)(wavelength::Q) where Q &lt;: Unitful.Length</code>. A generic fallback for inputs without units is already defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/core.jl#L86-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PhotometricFilters.get_metadata"><a class="docstring-binding" href="#PhotometricFilters.get_metadata"><code>PhotometricFilters.get_metadata</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_metadata()</code></pre><p>Returns a table of the available parameters that can be used to query the SVO filter service from the <code>FORMAT=metadata</code> VOTable they provide.</p><p>The table is a <code>DataFrame</code> from the <a href="https://github.com/JuliaData/DataFrames.jl"><code>DataFrames</code></a> package with the following columns:</p><ul><li><code>parameter</code>: parameter name that can be used for queries using <a href="#PhotometricFilters.query_filters"><code>query_filters</code></a></li><li><code>unit</code>: <a href="https://github.com/JuliaPhysics/Unitful.jl"><code>Unitful</code></a> unit of the parameter</li><li><code>datatype</code>: <code>Type</code> of the parameter</li><li><code>description</code>: description of the parameter</li><li><code>values</code>: vector of the possible values that the respective parameter can take on (e.g. for Instrument), or a vector of the minimum and maximum values that the parameter can assume (e.g. for WavelengthEff)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFrames: DataFrame

julia&gt; df = PhotometricFilters.get_metadata();

julia&gt; df isa DataFrame
true

julia&gt; facilities = df[findfirst(==(&quot;Facility&quot;), df.parameter), :].values;

julia&gt; facilities isa Vector{String}
true</code></pre><p>This is not exported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/PhotometricFilters.jl/blob/d73506c5cac6f0264a67a535970ec9b997842264/src/svo.jl#L233-L264">source</a></section></details></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#PhotometricFilters.AB"><code>PhotometricFilters.AB</code></a></li><li><a href="#PhotometricFilters.AbstractFilter"><code>PhotometricFilters.AbstractFilter</code></a></li><li><a href="#PhotometricFilters.MagnitudeSystem"><code>PhotometricFilters.MagnitudeSystem</code></a></li><li><a href="#PhotometricFilters.PhotometricFilter"><code>PhotometricFilters.PhotometricFilter</code></a></li><li><a href="#PhotometricFilters.ST"><code>PhotometricFilters.ST</code></a></li><li><a href="#PhotometricFilters.SVOFilter"><code>PhotometricFilters.SVOFilter</code></a></li><li><a href="#PhotometricFilters.Vega-Tuple{String}"><code>PhotometricFilters.Vega</code></a></li><li><a href="#PhotometricFilters.Vega"><code>PhotometricFilters.Vega</code></a></li><li><a href="#PhotometricFilters.F_lambda"><code>PhotometricFilters.F_lambda</code></a></li><li><a href="#PhotometricFilters.F_nu"><code>PhotometricFilters.F_nu</code></a></li><li><a href="#PhotometricFilters.apply_throughput"><code>PhotometricFilters.apply_throughput</code></a></li><li><a href="#PhotometricFilters.apply_throughput!"><code>PhotometricFilters.apply_throughput!</code></a></li><li><a href="#PhotometricFilters.cached_filters"><code>PhotometricFilters.cached_filters</code></a></li><li><a href="#PhotometricFilters.central_wavelength"><code>PhotometricFilters.central_wavelength</code></a></li><li><a href="#PhotometricFilters.clear_filter"><code>PhotometricFilters.clear_filter</code></a></li><li><a href="#PhotometricFilters.detector_type"><code>PhotometricFilters.detector_type</code></a></li><li><a href="#PhotometricFilters.effective_wavelength"><code>PhotometricFilters.effective_wavelength</code></a></li><li><a href="#PhotometricFilters.filtername"><code>PhotometricFilters.filtername</code></a></li><li><a href="#PhotometricFilters.fwhm"><code>PhotometricFilters.fwhm</code></a></li><li><a href="#PhotometricFilters.get_calspec_names"><code>PhotometricFilters.get_calspec_names</code></a></li><li><a href="#PhotometricFilters.get_filter"><code>PhotometricFilters.get_filter</code></a></li><li><a href="#PhotometricFilters.get_metadata"><code>PhotometricFilters.get_metadata</code></a></li><li><a href="#PhotometricFilters.magnitude"><code>PhotometricFilters.magnitude</code></a></li><li><a href="#PhotometricFilters.max_wave"><code>PhotometricFilters.max_wave</code></a></li><li><a href="#PhotometricFilters.mean_flux_density"><code>PhotometricFilters.mean_flux_density</code></a></li><li><a href="#PhotometricFilters.mean_wavelength"><code>PhotometricFilters.mean_wavelength</code></a></li><li><a href="#PhotometricFilters.min_wave"><code>PhotometricFilters.min_wave</code></a></li><li><a href="#PhotometricFilters.pivot_wavelength"><code>PhotometricFilters.pivot_wavelength</code></a></li><li><a href="#PhotometricFilters.query_filters"><code>PhotometricFilters.query_filters</code></a></li><li><a href="#PhotometricFilters.reference_wavelength"><code>PhotometricFilters.reference_wavelength</code></a></li><li><a href="#PhotometricFilters.throughput"><code>PhotometricFilters.throughput</code></a></li><li><a href="#PhotometricFilters.update_filter"><code>PhotometricFilters.update_filter</code></a></li><li><a href="#PhotometricFilters.wavelength"><code>PhotometricFilters.wavelength</code></a></li><li><a href="#PhotometricFilters.width"><code>PhotometricFilters.width</code></a></li><li><a href="#PhotometricFilters.zeropoint_Jy"><code>PhotometricFilters.zeropoint_Jy</code></a></li><li><a href="#PhotometricFilters.zeropoint_flux"><code>PhotometricFilters.zeropoint_flux</code></a></li><li><a href="#PhotometricFilters.zeropoint_mag"><code>PhotometricFilters.zeropoint_mag</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 5 December 2025 21:19">Friday 5 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
